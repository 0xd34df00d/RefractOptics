\documentclass[11pt,a4paper]{article}
\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{graphics,graphicx,epsfig}
\usepackage{amssymb,amsfonts,amsthm,amsmath,mathtext,cite,enumerate,float}
\usepackage[english,russian]{babel}
\usepackage{pgf}
\usepackage{tikz}
\usepackage{scalefnt}
\usepackage{listings}
\usepackage{float}
\usepackage{verbatim}
\usepackage{url}
\usepackage{babelbib}
\usepackage{grffile}
\usepackage{color}
\usepackage{xfrac}
\usepackage{comment}
\usepackage{rotating}
\usepackage{slashbox}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{lstautogobble}

\lstset{language=C++}

\lstloadlanguages{C++}

\begin{document}

УДК 519.683.8
\begin{center}
  \textbf{Символьное вычисление производных функций многих переменных во время компиляции средствами шаблонов C++}

  \bigskip
  Г.\,И.~Рудой
  Московский физико-технический институт, 0xd34df00d@gmail.com
\end{center}

\section{Введение}

Задача вычисления производных сложной функции возникает во многих вычислительных
задачах, таких как численная оптимизация, построение регрессионных моделей
\cite{Rudoy16StabilityAnalysis} и тому подобные. Во многих случаях функция,
производные которой необходимо вычислить, известна наперед во время написания
программы.

Одним из подходов к решению этой задачи, помимо автоматического дифференцирования \cite{Neidinger2010Introduction},
является получение аналитических выражений для производных в явном виде либо вручную,
либо при помощи различных математических пакетов, и последующее программирование
полученных производных в виде соответствующей последовательности операторов целевого
языка программирования.

Подобный подход позволяет добиться хорошей производительности, поскольку вычисление
таких выражений может быть оптимизировано на этапе компиляции, но вместе с этим он
имеет и ряд минусов, как то:
\begin{itemize}
  \item возможность допустить труднообнаружимую ошибку или опечатку при
	программировании выражений для производных,
  \item необходимость вручную обновлять все соответствующие выражения при модификации
	исходной функции, производные которой необходимо вычислять,
  \item отсутствие гарантий со стороны компилятора и системы типов, что в коде
	программы вычисляются производные, вообще говоря, той функции, что ожидается.
\end{itemize}

В предлагаемом решении для языка C++ производные функций не указываются в явном виде,
а вычисляются средствами компилятора в процессе компиляции программы. При этом у
компилятора остается возможность применить все те же оптимизации, которые были бы
использованы при ручном программировании выражений для производных.

В вычислительном эксперименте метод применен к вычислению производных функции,
описывающей мощность лазера как функцию прозрачности его резонатора, и производительность
этого метода сравнена с вручную оптимизированным кодом вычисления соответствующих
производных.

\section{Постановка задачи}

Пусть дана некоторая функция многих переменных $y = f(\boldsymbol{x})$, где
$\boldsymbol{x} \in \mathbb{R}^n, \boldsymbol{x} = (x_1, \dots, x_n)$. Требуется
выразить эту функцию в виде кода на C++ таким образом, чтобы не требовалось вручную
указывать выражения для $\frac{\partial f}{\partial x_i}$, сохранив при этом возможность
применения оптимизаций компилятора к вычислению этих выражений.

Отметим, что требование возможности компиляторных оптимизаций заставляет отказаться
от решений, представляющих функцию $f$ в виде древообразной структуры, обход и дифференцирование
которой происходит во время выполнения.

\section{Представление функций}

В предлагаемом решении функция $f$ представляется в виде некоторого типа, который
выводится компилятором для композиции заранее заданных базовых термов. Так, например,
функция $f(x_1) = x_1^{x_1}$ указывается следующим образом:
\begin{lstlisting}
using Formula_t = decltype (Pow (x1, x1));
\end{lstlisting}
где \texttt{x1} и \texttt{Pow} ~--- определенные в предлагаемой библиотеке термы,
представляющие соответственно свободную переменную и операцию возведения в степень.

Отметим, что использование типов для представления функций вместе со вспомогательными
функциями (таких, как \texttt{Pow}), имеющими объявления, но не определения,
гарантирует, что дифференцирование действительно происходит во время компиляции программы.

Тип функции $f$ строится как рекурсивное дерево выражения. Для представления узла
дерева используется следующая структура:
\begin{lstlisting}
template<typename NodeClass, typename... Args>
struct Node;
\end{lstlisting}
где \texttt{NodeClass}~--- тип узла (например, переменная, константа, унарная функция,
бинарная функция), а \texttt{Args}~--- параметры этого узла (например, индекс переменной,
значение константы, дочерний узел унарной функции, дочерние узлы бинарной функции
соответственно).

Специализации \texttt{Node} поддерживают следующую функциональность:
\begin{itemize}
  \item взятие производной по правилу дифференцирования сложных функций;
  \item вычисление значения узла согласно его параметрам в данной точке;
  \item формирование текстового представления узла.
\end{itemize}

\subsection{Целочисленные константы}
Для определения узла, соответствующего целочисленной константе, сначала определим
вспомогательный тип:
\begin{lstlisting}
using NumberType_t = long long;

template<NumberType_t N>
struct Number {};
\end{lstlisting}

Тогда узел, соответствующий целочисленной константе, представляется следующим образом:
\begin{lstlisting}
template<NumberType_t N>
struct Node<Number<N>>
{
  template<char FPrime, int IPrime>
  using Derivative_t = Node<Number<0>>;

  static std::string Print ()
  {
    return std::to_string (N);
  }

  template<typename Vec>
  static typename Vec::value_type Eval (const Vec&)
  {
    return N;
  }

  constexpr Node () {}
};
\end{lstlisting}

Действительно, производная любого числа~--- ноль (этому соответствует тип \texttt{Derivative\_t},
параметры которого рассмотрим позже). Функция \texttt{Print} обеспечивает преобразование
целочисленной константы в строку, а функция \texttt{Eval}, обеспечивающая вычисление
значения узла в данной точке, возвращает значение этой константы. Параметры функции
\texttt{Eval} рассмотрим далее.


\end{document}
