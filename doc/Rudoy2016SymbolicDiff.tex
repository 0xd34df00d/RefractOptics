\documentclass[11pt,a4paper]{article}
\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{graphics,graphicx,epsfig}
\usepackage{amssymb,amsfonts,amsthm,amsmath,mathtext,cite,enumerate,float}
\usepackage[english,russian]{babel}
\usepackage{pgf}
\usepackage{tikz}
\usepackage{scalefnt}
\usepackage{listings}
\usepackage{float}
\usepackage{verbatim}
\usepackage{url}
\usepackage{babelbib}
\usepackage{grffile}
\usepackage{color}
\usepackage{xfrac}
\usepackage{comment}
\usepackage{rotating}
\usepackage{slashbox}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{lstautogobble}

\lstset{language=C++}

\lstloadlanguages{C++}

\begin{document}

УДК 519.683.8
\begin{center}
  \textbf{Символьное вычисление производных функций многих переменных во время компиляции средствами шаблонов C++}

  \bigskip
  Г.\,И.~Рудой
  Московский физико-технический институт, 0xd34df00d@gmail.com
\end{center}

\section{Введение}

Задача вычисления производных сложной функции возникает во многих вычислительных
задачах, таких как численная оптимизация, построение регрессионных моделей
\cite{Rudoy16StabilityAnalysis} и тому подобные. Во многих случаях функция,
производные которой необходимо вычислить, известна наперед во время написания
программы.

Одним из подходов к решению этой задачи, помимо автоматического дифференцирования \cite{Neidinger2010Introduction},
является получение аналитических выражений для производных в явном виде либо вручную,
либо при помощи различных математических пакетов, и последующее программирование
полученных производных в виде соответствующей последовательности операторов целевого
языка программирования.

Подобный подход позволяет добиться хорошей производительности, поскольку вычисление
таких выражений может быть оптимизировано на этапе компиляции, но вместе с этим он
имеет и ряд минусов, как то:
\begin{itemize}
  \item возможность допустить труднообнаружимую ошибку или опечатку при
	программировании выражений для производных,
  \item необходимость вручную обновлять все соответствующие выражения при модификации
	исходной функции, производные которой необходимо вычислять,
  \item отсутствие гарантий со стороны компилятора и системы типов, что в коде
	программы вычисляются производные, вообще говоря, той функции, что ожидается.
\end{itemize}

В предлагаемом решении для языка C++ производные функций не указываются в явном виде,
а вычисляются средствами компилятора в процессе компиляции программы. При этом у
компилятора остается возможность применить все те же оптимизации, которые были бы
использованы при ручном программировании выражений для производных.

В вычислительном эксперименте метод применен к вычислению производных функции,
описывающей мощность лазера как функцию прозрачности его резонатора, и производительность
этого метода сравнена с вручную оптимизированным кодом вычисления соответствующих
производных.

\section{Постановка задачи}

Пусть дана некоторая функция многих переменных $y = f(\boldsymbol{x})$, где
$\boldsymbol{x} \in \mathbb{R}^n, \boldsymbol{x} = (x_1, \dots, x_n)$. Требуется
выразить эту функцию в виде кода на C++ таким образом, чтобы не требовалось вручную
указывать выражения для $\frac{\partial f}{\partial x_i}$, сохранив при этом возможность
применения оптимизаций компилятора к вычислению этих выражений.

Отметим, что требование возможности компиляторных оптимизаций заставляет отказаться
от решений, представляющих функцию $f$ в виде древообразной структуры, обход и дифференцирование
которой происходит во время выполнения.

\section{Представление функций}

В предлагаемом решении функция $f$ представляется в виде некоторого типа, который
выводится компилятором для композиции заранее заданных базовых термов. Так, например,
функция $f(x_1) = x_1^{x_1}$ указывается следующим образом:
\begin{lstlisting}
using Formula_t = decltype (Pow (x1, x1));
\end{lstlisting}
где \texttt{x1} и \texttt{Pow} ~--- определенные в предлагаемой библиотеке термы,
представляющие соответственно свободную переменную и операцию возведения в степень.

Отметим, что использование типов для представления функций вместе со вспомогательными
функциями (таких, как \texttt{Pow}), имеющими объявления, но не определения,
гарантирует, что дифференцирование действительно происходит во время компиляции программы.

Тип функции $f$ строится как рекурсивное дерево выражения. Для представления узла
дерева используется следующая структура:
\begin{lstlisting}
template<typename NodeClass, typename... Args>
struct Node;
\end{lstlisting}
где \texttt{NodeClass}~--- тип узла (например, переменная, константа, унарная функция,
бинарная функция), а \texttt{Args}~--- параметры этого узла (например, индекс переменной,
значение константы, дочерний узел унарной функции, дочерние узлы бинарной функции
соответственно).

Специализации \texttt{Node} поддерживают следующую функциональность:
\begin{itemize}
  \item взятие производной по правилу дифференцирования сложных функций;
  \item вычисление значения узла согласно его параметрам в данной точке;
  \item формирование текстового представления узла.
\end{itemize}

\subsection{Целочисленные константы}
Для определения узла, соответствующего целочисленной константе, сначала определим
вспомогательный тип:
\begin{lstlisting}
using NumberType_t = long long;

template<NumberType_t N>
struct Number {};
\end{lstlisting}

Тогда узел, соответствующий целочисленной константе, представляется следующим образом:
\begin{lstlisting}
template<NumberType_t N>
struct Node<Number<N>>
{
  template<char FPrime, int IPrime>
  using Derivative_t = Node<Number<0>>;

  static std::string Print ()
  {
    return std::to_string (N);
  }

  template<typename Vec>
  static typename Vec::value_type Eval (const Vec&)
  {
    return N;
  }

  constexpr Node () {}
};
\end{lstlisting}

Действительно, производная любого числа~--- ноль (этому соответствует тип \texttt{Derivative\_t},
параметры которого рассмотрим позже). Функция \texttt{Print} обеспечивает преобразование
целочисленной константы в строку, а функция \texttt{Eval}, обеспечивающая вычисление
значения узла в данной точке, возвращает значение этой константы. Параметры функции
\texttt{Eval} рассмотрим далее.

\subsection{Свободные переменные}

Для определения переменной также введем вспомогательный тип:
\begin{lstlisting}
template<char Family, int Index>
struct Variable {};
\end{lstlisting}
где \texttt{Family} и \texttt{index}~--- <<семейство>> и индекс переменной. Так, например,
для $w_0$ они равны, соответственно, \texttt{'w'} и \texttt{0}.

Рассмотрим определение узла для свободной переменной:
\begin{lstlisting}
template<char Family, int Index>
struct Node<Variable<Family, Index>>
{
  template<char FPrime, int IPrime>
  using Derivative_t = std::conditional_t<FPrime == Family && IPrime == Index,
      Node<Number<1>>,
      Node<Number<0>>>;

  static std::string Print ()
  {
    return std::string { Family, '_' } + std::to_string (Index);
  }

  template<typename Vec>
  static typename Vec::value_type Eval (const Vec& values)
  {
    return values (Node {});
  }

  constexpr Node () {}
};
\end{lstlisting}

Так, производная переменной равна единице, если производная берется по самой этой переменной,
и нулю иначе. Собственно, параметры \texttt{FPrime} и \texttt{IPrime} типа \texttt{Derivative\_t}
соответствуют семейству и индексу переменной, по которой вычисляется производная.

Функция \texttt{Eval}, вычисляющая значение переменной, создает безымянный объект того же типа,
что и узел, и вызывает переданный объект \texttt{values} с этим типом. Соответствующая перегрузка
\texttt{operator()} у типа \texttt{Vec} обеспечивает выбор значеничя, соответствующего типу
\texttt{Node}. Детальная реализация типа \texttt{Vec} рассмотрена далее.

Отметим, что известный на этапе компиляции тип \texttt{Node} и, как следствие, известная на этапе
компиляции перегрузка \texttt{Vec::operator()} обеспечивают компилятору возможность прямо подставить
соответствующее значение переменной (пусть и известное лишь на этапе выполнения), как если бы оно
было указано вручную.

\subsection{Унарные функции}

Для указания конкретной унарной функции вводится перечисление \texttt{UnaryFunction} и
соответствующий тип \texttt{UnaryFunctionWrapper}, а также некоторые синонимы типов для удобства
дальнейшего использования:
\begin{lstlisting}
enum class UnaryFunction
{
  Sin,
  Cos,
  Ln,
  Neg
};

template<UnaryFunction UF>
struct UnaryFunctionWrapper;

using Sin = UnaryFunctionWrapper<UnaryFunction::Sin>;
using Cos = UnaryFunctionWrapper<UnaryFunction::Cos>;
using Neg = UnaryFunctionWrapper<UnaryFunction::Neg>;
using Ln = UnaryFunctionWrapper<UnaryFunction::Ln>;
\end{lstlisting}

В специализациях \texttt{UnaryFunctionWrapper} реализована логика взятия производных каждой
конкретной унарной функции:

\begin{lstlisting}
template<>
struct UnaryFunctionWrapper<UnaryFunction::Sin>
{
  template<typename Child>
  using Derivative_t = Node<Cos, Child>;
};

template<>
struct UnaryFunctionWrapper<UnaryFunction::Cos>
{
  template<typename Child>
  using Derivative_t = Node<Neg, Node<Sin, Child>>;
};

template<>
struct UnaryFunctionWrapper<UnaryFunction::Ln>
{
  template<typename Child>
  using Derivative_t = Node<Div, Node<Number<1>>, Child>;
};

template<>
struct UnaryFunctionWrapper<UnaryFunction::Neg>
{
  template<typename>
  using Derivative_t = Node<Number<-1>>;
};
\end{lstlisting}

При этом дальнейшее дифференцирование дочернего узла производится
соответствующей специализацией \texttt{Node}:

\begin{lstlisting}
template<UnaryFunction UF, typename... ChildArgs>
struct Node<UnaryFunctionWrapper<UF>, Node<ChildArgs...>>
{
	using Child_t = Node<ChildArgs...>;

	template<char FPrime, int IPrime>
	using Derivative_t = Node<Mul,
			typename UnaryFunctionWrapper<UF>::template Derivative_t<Child_t>,
			typename Node<ChildArgs...>::template Derivative_t<FPrime, IPrime>>;

	static std::string Print ()
	{
		return FunctionName (UF) + "(" + Node<ChildArgs...>::Print () + ")";
	}

	template<typename Vec>
	static typename Vec::value_type Eval (const Vec& values)
	{
		const auto child = Child_t::Eval (values);
		return EvalUnary (UnaryFunctionWrapper<UF> {}, child);
	}
};
\end{lstlisting}

Соответственно, определение типа \texttt{Derivative\_t} для данной специализации
\texttt{Node} вычисляет производную унарной функции согласно \texttt{UnaryFunctionWrapper},
рекурсивно вычисляет производную дочернего узла, и затем перемножает их согласно правилу
взятия производых сложной функции. Подобное разделение логики взятия производных позволяет
избежать дублирования кода.

Функция \texttt{Eval} вычисляет значение дочернего узла, а затем вызывает соответствующую
перегрузку \texttt{EvalUnary}. Определения перегрузок последней достаточно тривиальны:
\begin{lstlisting}
template<typename T>
T EvalUnary (const Sin&, T value)
{
	return std::sin (value);
}

template<typename T>
T EvalUnary (const Cos&, T value)
{
	return std::cos (value);
}

template<typename T>
T EvalUnary (const Ln&, T value)
{
	return std::log (value);
}

template<typename T>
T EvalUnary (const Neg&, T value)
{
	return -value;
}
\end{lstlisting}

Отметим, что операцию \texttt{Neg} можно и не вводить, заменяя ее на умножение на
минус единицу.

\subsection{Бинарные функции}

Представление бинарных функций аналогично унарным. Для полноты введем используемые далее
типы:
\begin{lstlisting}
enum class BinaryFunction
{
	Add,
	Mul,
	Div,
	Pow
};

using Add = BinaryFunctionWrapper<BinaryFunction::Add>;
using Mul = BinaryFunctionWrapper<BinaryFunction::Mul>;
using Div = BinaryFunctionWrapper<BinaryFunction::Div>;
using Pow = BinaryFunctionWrapper<BinaryFunction::Pow>;
\end{lstlisting}


\end{document}
