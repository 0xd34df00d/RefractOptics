\documentclass[11pt,a4paper]{article}
\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{graphics,graphicx,epsfig}
\usepackage{amssymb,amsfonts,amsthm,amsmath,mathtext,cite,enumerate,float}
\usepackage[english,russian]{babel}
\usepackage{pgf}
\usepackage{tikz}
\usepackage{scalefnt}
\usepackage{listings}
\usepackage{float}
\usepackage{verbatim}
\usepackage{url}
\usepackage{babelbib}
\usepackage{grffile}
\usepackage{color}
\usepackage{xfrac}
\usepackage{comment}
\usepackage{rotating}
\usepackage{slashbox}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{lstautogobble}

\lstset{language=C++}

\lstloadlanguages{C++}

\begin{document}

УДК 519.683.8
\begin{center}
  \textbf{Символьное вычисление производных функций многих переменных во время компиляции средствами шаблонов C++}

  \bigskip
  Г.\,И.~Рудой
  Московский физико-технический институт, 0xd34df00d@gmail.com
\end{center}

\section{Введение}

Задача вычисления производных сложной функции возникает во многих вычислительных
задачах, таких как численная оптимизация, построение регрессионных моделей
\cite{Rudoy16StabilityAnalysis} и тому подобные. Во многих случаях функция,
производные которой необходимо вычислить, известна наперед во время написания
программы.

Одним из подходов к решению этой задачи, помимо автоматического дифференцирования \cite{Neidinger2010Introduction},
является получение аналитических выражений для производных в явном виде либо вручную,
либо при помощи различных математических пакетов, и последующее программирование
полученных производных в виде соответствующей последовательности операторов целевого
языка программирования.

Подобный подход позволяет добиться хорошей производительности, поскольку вычисление
таких выражений может быть оптимизировано на этапе компиляции, но вместе с этим он
имеет и ряд минусов, как то:
\begin{itemize}
  \item возможность допустить труднообнаружимую ошибку или опечатку при
	программировании выражений для производных,
  \item необходимость вручную обновлять все соответствующие выражения при модификации
	исходной функции, производные которой необходимо вычислять,
  \item отсутствие гарантий со стороны компилятора и системы типов, что в коде
	программы вычисляются производные, вообще говоря, той функции, что ожидается.
\end{itemize}

В предлагаемом решении для языка C++ производные функций не указываются в явном виде,
а вычисляются средствами компилятора в процессе компиляции программы. При этом у
компилятора остается возможность применить все те же оптимизации, которые были бы
использованы при ручном программировании выражений для производных.

В вычислительном эксперименте метод применен к вычислению производных функции,
описывающей мощность лазера как функцию прозрачности его резонатора, и производительность
этого метода сравнена с вручную оптимизированным кодом вычисления соответствующих
производных.

\section{Постановка задачи}

Пусть дана некоторая функция многих переменных $y = f(\boldsymbol{x})$, где
$\boldsymbol{x} \in \mathbb{R}^n, \boldsymbol{x} = (x_1, \dots, x_n)$. Требуется
выразить эту функцию в виде кода на C++ таким образом, чтобы не требовалось вручную
указывать выражения для $\frac{\partial f}{\partial x_i}$, сохранив при этом возможность
применения оптимизаций компилятора к вычислению этих выражений.

Отметим, что требование возможности компиляторных оптимизаций заставляет отказаться
от решений, представляющих функцию $f$ в виде древообразной структуры, обход и дифференцирование
которой происходит во время выполнения.


\end{document}
