/**********************************************************************
 * Regression and stability estimation.
 * Copyright (C) 2013  Georg Rudoy
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include <iostream>
#include <random>
#include <vector>
#include <boost/lexical_cast.hpp>
#include "solve.h"

std::vector<double> generateXs (double from, double to, size_t samples)
{
	std::random_device generator;
	std::uniform_real_distribution<> distr (from, to);

	std::vector<double> result;
	result.reserve (samples);

	for (size_t i = 0; i < samples; ++i)
		result.push_back (distr (generator));

	return result;
}

std::vector<double> generateYs (const std::vector<double>& xs, double a, double b, double variance)
{
	std::random_device generator;
	std::normal_distribution<> distr (0, variance);

	std::vector<double> result;
	result.reserve (xs.size ());

	for (auto x : xs)
		result.push_back (a + b * x + (variance ? distr (generator) : 0.0));

	return result;
}

int main (int argc, char **argv)
{
	if (argc < 7)
	{
		std::cerr << "Usage: " << argv [0] << " a b from to num_samples variance" << std::endl;
		return 0;
	}

	const double a = boost::lexical_cast<double> (argv [1]);
	const double b = boost::lexical_cast<double> (argv [2]);
	const double from = boost::lexical_cast<double> (argv [3]);
	const double to = boost::lexical_cast<double> (argv [4]);
	const size_t samples = boost::lexical_cast<size_t> (argv [5]);
	const double variance = boost::lexical_cast<double> (argv [6]);

	std::cout << "computing " << a << " + " << b << "x" << " on [" << from << ":" << to << "] with " << samples << " samples and " << variance << " variance" << std::endl;

	const auto& srcXs = generateXs (from, to, samples);
	auto xs = srcXs;
	const auto xAvg = std::accumulate (xs.begin (), xs.end (), 0.0) / samples;
	for (auto& x : xs)
		x -= xAvg;

	const auto& ys = generateYs (xs, a, b, variance);

	const auto diffs = std::accumulate (srcXs.begin (), srcXs.end (), 0.0, [xAvg] (double res, double x) { return res + std::pow (x - xAvg, 2); });

	std::vector<std::pair<SampleType_t<>, double>> pairs;
	for (auto ix = xs.cbegin (), iy = ys.begin (); ix != xs.cend (); ++ix, ++iy)
	{
		SampleType_t<> sample;
		sample (0) = *ix;
		pairs.push_back ({ sample, *iy });
	}

	auto res = [] (const std::pair<SampleType_t<>, double>& data, const Params_t<2>& p)
		{ return p (0) + p (1) * data.first (0) - data.second; };
	auto der = [] (const std::pair<SampleType_t<>, double>& data, const Params_t<2>& p) -> Params_t<2>
	{
		Params_t<2> res;
		res (0) = 1;
		res (1) = data.first (0);
		return res;
	};

	const auto& p = solve<2> (pairs, res, der, {{ 1, 1 }});
	std::cout << "inferred params: " << dlib::trans (p) << std::endl;

	const auto& pca = solve<2> (pairs, res, der,
			[] (auto, const Params_t<2>& p) { return p (1); },
			[] (auto) { return 0.01; },
			[] (auto) { return 0.01; },
			{{ 1, 1 }});
	std::cout << "inferred 'fixed' L-M params: " << dlib::trans (pca) << std::endl;

	const auto da0 = variance * variance / samples;
	const auto da1 = variance * variance / diffs;
	std::cout << "book stuff: " << da0 << "; " << da1 << std::endl;

	std::cout << "real stuff diff: " << std::endl;
	auto solver = [res, der] (const TrainingSet_t<>& set) { return solve<2> (set, res, der, {{ 1, 1 }}); };
	StatsKeeper<decltype (solver)> keeper (solver, 0, variance, pairs, false);

	std::ofstream ostr (std::string ("linear_log_") + argv [1] + "x_" + argv [2] + "_samples_" + argv [5] + "_variance_" + argv [6] + ".log");
	std::ofstream ostrN (std::string ("linear_log_") + argv [1] + "x_" + argv [2] + "_samples_" + argv [5] + "_variance_" + argv [6] + "_norm.log");

	for (size_t i = 0; i < 100000; ++i)
	{
		keeper.TryMore (1000);
		const auto& stats = keeper.GetRunning ();

		const auto diff0 = std::abs (std::pow (stats [0].stddev (), 2) - da0);
		const auto diff1 = std::abs (std::pow (stats [1].stddev (), 2) - da1);

		if (!(i % 10))
		{
			std::cout << "\t" << i << "\t" << diff0 << ";\t\t";
			std::cout << diff1 << std::endl;
		}

		ostr << i << " " << diff0 << " " << diff1 << std::endl;
		ostrN << i << " " << diff0 / da0 << " " << diff1 / da1 << std::endl;
	}

	return 0;
}
