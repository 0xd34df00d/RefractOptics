/**********************************************************************
 * Regression and stability estimation.
 * Copyright (C) 2013  Georg Rudoy
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include "symbregmodels.h"
#include <iammad/diff.h>
#include <iammad/parse.h>
#include <iammad/params.h>
#include <iammad/simplify.h>

namespace Models
{
/**********************************************************************
 * Series
 **********************************************************************/
std::array<DType_t, Series::ParamsCount> Series::initial ()
{
	return {{ 1, 1, 1 }};
}

DType_t Series::residual (const std::pair<SampleType_t<>, DType_t>& data, const Params_t<ParamsCount>& p)
{
	DType_t result = 0;
	const auto x = data.first (0);
	for (size_t i = 0; i < ParamsCount; ++i)
		result += p (i) / std::pow (x, 2 * i);
	return result - data.second;
}

Params_t<Series::ParamsCount> Series::residualDer (const std::pair<SampleType_t<>, DType_t>& data, const Params_t<ParamsCount>& p)
{
	Params_t<ParamsCount> res;
	const auto x = data.first (0);
	for (size_t i = 0; i < ParamsCount; ++i)
		res (i) = 1 / std::pow (x, 2 * i);
	return res;
}

SampleType_t<> Series::varsDer (const std::pair<SampleType_t<>, DType_t>& data, const Params_t<ParamsCount>& p)
{
	const auto x = data.first (0);

	auto subDerivative = [] (DType_t x, int64_t i, DType_t p_i)
	{
		return -2 * i * p_i * std::pow (x, -2 * i - 1);
	};

	DType_t result = 0;
	for (size_t i = 1; i < ParamsCount; ++i)
		result += subDerivative (x, static_cast<int64_t> (i), p (i));

	SampleType_t<> res;
	res (0) = result;
	return res;
}

TrainingSet_t<> Series::preprocess (const TrainingSet_t<>& srcPts)
{
	return srcPts;
}

/**********************************************************************
 * Laser
 **********************************************************************/
std::array<DType_t, Laser::ParamsCount> Laser::initial ()
{
	return {{ 0.002, 0.0002, 100 }};
}

namespace
{
	DType_t alpha0MinusLn (DType_t alpha0, DType_t logr0, DType_t L)
	{
		return alpha0 - logr0 / L;
	}
}

#define USE_MAD 1

DType_t Laser::residual (const std::pair<SampleType_t<IndependentCount>, DType_t>& data, const Params_t<ParamsCount>& p)
{
#if USE_MAD
	const auto& vec = BindParams (data.first, p);
	return Formula_t::Eval (vec) - data.second;
#else
	const auto r0 = data.first (0);
	const auto logr0 = data.first (1);
	const auto g0 = p (0);
	const auto alpha0 = p (1);
	const auto k = p (2);

	return k * (1 - r0) / (1 + r0) * (g0 / alpha0MinusLn (alpha0, logr0, L) - 1) - data.second;
#endif
}

Params_t<Laser::ParamsCount> Laser::residualDer (const std::pair<SampleType_t<IndependentCount>, DType_t>& data, const Params_t<ParamsCount>& p)
{
#if USE_MAD
	const auto& vec = BindParams (data.first, p);

	using Simplify::Simplify_t;
	using namespace LaserDetail;

	Params_t<ParamsCount> res;
	res (0) = Simplify_t<VarDerivative_t<Formula_t, decltype (g0)>>::Eval (vec);
	res (1) = Simplify_t<VarDerivative_t<Formula_t, decltype (alpha0)>>::Eval (vec);
	res (2) = Simplify_t<VarDerivative_t<Formula_t, decltype (k)>>::Eval (vec);
	return res;
#else
	const auto r0 = data.first (0);
	const auto logr0 = data.first (1);
	const auto g0 = p (0);
	const auto alpha0 = p (1);
	const auto k = p (2);

	const auto frac = (1 - r0) / (1 + r0);

	const auto a0ml = alpha0MinusLn (alpha0, logr0, L);
	const auto dg0 = k * frac / a0ml;
	const auto dalpha0 = -g0 * k * frac / (a0ml * a0ml);
	const auto dk = frac * (g0 / a0ml - 1);

	Params_t<ParamsCount> res;
	res (0) = dg0;
	res (1) = dalpha0;
	res (2) = dk;
	return res;
#endif
}

SampleType_t<> Laser::varsDer (const std::pair<SampleType_t<IndependentCount>, DType_t>& data, const Params_t<ParamsCount>& p)
{
#if USE_MAD
	const auto& vec = BindParams (data.first, p);

	using Simplify::Simplify_t;
	using namespace LaserDetail;

	SampleType_t<> res;
	res (0) = Simplify_t<VarsDer_t>::Eval (vec);
	return res;
#else
	const auto r0 = data.first (0);
	const auto logr0 = data.first (1);
	const auto r0sq = data.first (2);
	const auto r0frac = data.first (3);

	const auto g0 = p (0);
	const auto alpha0 = p (1);
	const auto k = p (2);

	const auto a0ml = alpha0MinusLn (alpha0, logr0, L);
	auto result = (g0 / a0ml - 1) * r0sq;
	result += g0 * r0frac / (L * r0 * a0ml * a0ml);

	SampleType_t<> res;
	res (0) = result * k;
	return res;
#endif
}

TrainingSet_t<Laser::IndependentCount> Laser::preprocess (const TrainingSet_t<>& srcPts)
{
	TrainingSet_t<IndependentCount> res;
	for (const auto& srcPt : srcPts)
	{
		const auto val = srcPt.first (0);
		SampleType_t<IndependentCount> pt;
		pt (0) = val;
		pt (1) = std::log (val);
		pt (2) = -2 / ((1 + val) * (1 + val));
		pt (3) = (1 - val) / (1 + val);
		res.emplace_back (pt, srcPt.second);
	}
	return res;
}

/**********************************************************************
 * Resonance
 **********************************************************************/
DType_t Resonance::residual (const std::pair<SampleType_t<>, DType_t>& data, const Params_t<ParamsCount>& p)
{
	const auto x = data.first (0);
	const auto x2 = x * x;

	const DType_t cminus = p (2) - 1.0 / x2;
	const DType_t underRoot = p (0) + p (1) / cminus;
	const DType_t root = underRoot >= 0 ? std::sqrt(underRoot) : 10;

	return root - data.second;
}

Params_t<Resonance::ParamsCount> Resonance::residualDer (const std::pair<SampleType_t<>, DType_t>& data, const Params_t<ParamsCount>& p)
{
	const auto x = data.first (0);
	const auto x2 = x * x;

	const DType_t cminus = p (2) - 1.0 / x2;
	const DType_t underRoot = p (0) + p (1) / cminus;
	const DType_t root = underRoot > 0 ? std::sqrt(underRoot) : 10;

	Params_t<ParamsCount> res;
	res (0) = 1. / (2. * root);
	res (1) = 1. / (2. * root * cminus);
	res (2) = -(p (1) / (2 * root * cminus * cminus));
	return res;
}
}
