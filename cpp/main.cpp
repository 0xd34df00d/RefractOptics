/**********************************************************************
 * Regression and stability estimation.
 * Copyright (C) 2013  Georg Rudoy
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include <fstream>
#include <iostream>
#include <cstdlib>
#include <limits>
#include "solve.h"

const size_t ParamsCount = 3;

std::string format (double value)
{
	std::ostringstream ostr;
	ostr.precision (3);
	if (value > 1)
	{
		ostr << value;
		return ostr.str ();
	}
	if (value < 1e-7)
		return "0";

	int count = 0;
	if (value < 0.001)
		while (value < 1)
		{
			value *= 10;
			++count;
		}

	if (value != 1 || !count)
	{
		ostr << value;
		if (count)
			ostr << " \\cdot ";
	}
	if (count)
	{
		ostr << "10^{-";
		ostr << count;
		ostr << "}";
	}
	return ostr.str ();
}

namespace Series
{
	double residual (const std::pair<SampleType_t, double>& data, const Params_t<ParamsCount>& p)
	{
		double result = 0;
		const auto x = data.first (0);
		for (size_t i = 0; i < ParamsCount; ++i)
			result += p (i) / std::pow (x, 2 * i);
		return result - data.second;
	}

	Params_t<ParamsCount> residualDer (const std::pair<SampleType_t, double>& data, const Params_t<ParamsCount>& p)
	{
		Params_t<ParamsCount> res;
		const auto x = data.first (0);
		for (size_t i = 0; i < ParamsCount; ++i)
			res (i) = 1 / std::pow (x, 2 * i);
		return res;
	}
}

namespace Resonance
{
	double residual (const std::pair<SampleType_t, double>& data, const Params_t<ParamsCount>& p)
	{
		const auto x = data.first (0);
		const auto x2 = x * x;

		const double cminus = p (2) - 1.0 / x2;
		const double underRoot = p (0) + p (1) / cminus;
		const double root = underRoot >= 0 ? std::sqrt(underRoot) : 10;

		return root - data.second;
	}

	Params_t<ParamsCount> residualDer (const std::pair<SampleType_t, double>& data, const Params_t<ParamsCount>& p)
	{
		const auto x = data.first (0);
		const auto x2 = x * x;

		const double cminus = p (2) - 1.0 / x2;
		const double underRoot = p (0) + p (1) / cminus;
		const double root = underRoot > 0 ? std::sqrt(underRoot) : 10;

		Params_t<ParamsCount> res;
		res (0) = 1. / (2. * root);
		res (1) = 1. / (2. * root * cminus);
		res (2) = -(p (1) / (2 * root * cminus * cminus));
		return res;
	}
}

using namespace Series;

int main (int argc, char **argv)
{
	if (argc < 2)
	{
		std::cout << "Usage: " << argv [0] << " datafile" << std::endl;
		return 1;
	}

	const std::string infile (argv[1]);

	std::vector<SampleType_t> samples;
	std::vector<double> labels;
	TrainingSet_t pairs;

	std::ifstream istr (infile);
	while (istr)
	{
		double lambda, n;
		char c;
		istr >> lambda >> c >> n;
		if (!istr)
			break;

		SampleType_t sample;
		sample (0) = lambda;

		samples.push_back (sample);
		labels.push_back (n);
		pairs.push_back ({ sample, n });
	}

	std::cout << "read " << samples.size () << " samples: " << std::endl;

	const auto& p = solve<ParamsCount> (pairs, residual, residualDer);
	std::cout << "inferred params: " << dlib::trans (p) << std::endl;

	double sum = 0;
	for (const auto& pair : pairs)
	{
		auto r = residual (pair, p);
		sum += r * r;
	}
	std::cout << "MSE: " << sum / pairs.size () << std::endl;

	std::cout << "calculating mean/dispersion..." << std::endl;

	std::vector<double> lVars;
	for (double i = 0; i < 1e-3; i += 1e-4)
		lVars.push_back (i);

	std::vector<double> nVars;
	for (double i = 0; i < 5e-4; i += 2e-5)
		nVars.push_back (i);

	auto results = calcStats ([] (const TrainingSet_t& pts)
				{ return solve<ParamsCount> (pts, residual, residualDer); },
			lVars, nVars, pairs);

	/*
	for (size_t i = 0; i < ParamsCount; ++i)
	{
		std::cout << "\\begin{tabular}{| l ";
		for (size_t i = 0; i < nVars.size (); ++i)
			std::cout << "| l ";
		std::cout << "|} \\hline\n";
		for (auto nVar : nVars)
			std::cout << " & $" << format (nVar) << "$";
		std::cout << "\\\\ \\hline\n";

		std::cout.precision (3);

		for (auto lVar : lVars)
		{
			std::cout << format (lVar);
			for (auto nVar : nVars)
			{
				const auto& stats = results [lVar] [nVar];
				std::cout << " & ";
				std::cout << "$\\displaystyle (" << format (stats [i].mean ()) << "; " << format (stats [i].stddev ()) << ")$";
			}
			std::cout << "\\\\ \\hline\n";
		}
		std::cout << "\\end{tabular}" << std::endl << std::endl;
	}
	*/

	for (size_t i = 0; i < ParamsCount; ++i)
	{
		std::stringstream fname;
		fname << infile << "_coeff" << i << ".dat";

		std::ofstream ostr (fname.str ());
		for (auto lVar : lVars)
		{
			for (auto nVar : nVars)
			{
				const auto& stats = results [lVar] [nVar];
				ostr << lVar * 1000 << " " << nVar * 1000 << " " << stats [i].stddev () / p (i) * 1000  << std::endl;
			}
			ostr << std::endl;
		}
		std::cout << "wrote " << fname.str () << std::endl;
	}
}
